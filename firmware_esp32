#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/i2c.h"
#include "driver/gpio.h"
#include "driver/ledc.h"
#include "driver/uart.h"
#include "esp_timer.h"

// ==========================================================
// 1. HARDWARE CONFIG
// ==========================================================
#define PIN_M1 25
#define PIN_M2 22
#define PIN_M3 18
#define PIN_M4 23
#define PIN_M5 26
#define PIN_M6 21

#define I2C_PORT       I2C_NUM_0
#define SDA_PIN        32
#define SCL_PIN        33
#define MS5837_ADDR    0x76
#define MPU9250_ADDR   0x68

#define UART_PORT      UART_NUM_2
#define TXD_PIN        17
#define RXD_PIN        16
#define BUF_SIZE       256

// ==========================================================
// 2. CONTROL PARAMETERS - ✅ OPTIMIZED FOR AI TRACKING
// ==========================================================
#define PWM_CENTER     1500
#define PWM_LIMIT      400
#define PWM_OFFSET     50

// DEPTH PID CONTROL
#define Z_KP           15.5f
#define Z_KI           2.5f      // ✅ Giảm từ 2.5 → 1.2 (vừa đủ loại sai số, không overshoot)
#define Z_KD           12.0f     // ✅ Tăng từ 10.5 → 12.0 (chống dao động)
#define Z_SCALE        150.0f

// HEADING HOLD PID
#define HEADING_KP     1.8f
#define HEADING_KI     0.01f
#define HEADING_KD     2.5f

#define GYRO_DEADBAND    2.0f
#define HEADING_DEADBAND 3.0f

// DEPTH FILTERING
#define FILTER_ALPHA   0.18f     // ✅ Tăng từ 0.15 → 0.18 (mượt hơn cho AI)
#define RAD2DEG        57.29578f

// ✅ INTEGRAL LIMITS
#define DEPTH_INTEGRAL_MAX      12.0f  // ✅ Giảm từ 20.0 → 12.0
#define TARGET_CHANGE_THRESHOLD 0.03f  // ✅ 3cm: nếu target thay đổi > 3cm → giảm integral

// ==========================================================
// 3. GLOBAL STATE
// ==========================================================
bool  is_armed = false;
bool  heading_hold_enabled = true;

float target_depth   = 0.0f;
float prev_target_depth = 0.0f;  // ✅ Lưu target trước đó để phát hiện thay đổi
float manual_yaw     = 0.0f;
float manual_surge   = 0.0f;

// Depth State
float smooth_z = 0.0f;
float prev_z   = 0.0f;
uint16_t C[8];
float pressure_baseline = 0.0f;

// ✅ DEPTH INTEGRAL
float depth_error_integral = 0.0f;

// IMU State
float gyro_z_offset = 0.0f;
float gyro_z_dps    = 0.0f;
float current_heading = 0.0f;
float target_heading  = 0.0f;

// PID State
float heading_error_integral = 0.0f;
float prev_heading_error = 0.0f;

int64_t last_time_us = 0;

// ==========================================================
// 4. LOW LEVEL INIT
// ==========================================================
void i2c_init()
{
    i2c_config_t conf = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = SDA_PIN,
        .scl_io_num = SCL_PIN,
        .sda_pullup_en = GPIO_PULLUP_ENABLE,
        .scl_pullup_en = GPIO_PULLUP_ENABLE,
        .master.clk_speed = 100000
    };
    i2c_param_config(I2C_PORT, &conf);
    i2c_driver_install(I2C_PORT, conf.mode, 0, 0, 0);
}

void pwm_init()
{
    ledc_timer_config_t timer = {
        .speed_mode = LEDC_HIGH_SPEED_MODE,
        .timer_num = LEDC_TIMER_0,
        .duty_resolution = LEDC_TIMER_13_BIT,
        .freq_hz = 50,
        .clk_cfg = LEDC_AUTO_CLK
    };
    ledc_timer_config(&timer);

    int pins[6] = {PIN_M1, PIN_M2, PIN_M3, PIN_M4, PIN_M5, PIN_M6};

    for (int i = 0; i < 6; i++) {
        ledc_channel_config_t ch = {
            .speed_mode = LEDC_HIGH_SPEED_MODE,
            .channel = i,
            .timer_sel = LEDC_TIMER_0,
            .intr_type = LEDC_INTR_DISABLE,
            .gpio_num = pins[i],
            .duty = 0,
            .hpoint = 0
        };
        ledc_channel_config(&ch);
    }
}

void uart_init()
{
    uart_config_t cfg = {
        .baud_rate = 57600,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
        .source_clk = UART_SCLK_DEFAULT
    };
    uart_driver_install(UART_PORT, BUF_SIZE * 2, 0, 0, NULL, 0);
    uart_param_config(UART_PORT, &cfg);
    uart_set_pin(UART_PORT, TXD_PIN, RXD_PIN,
                 UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);
}

void set_pwm(int ch, int us)
{
    if (us < 1100) us = 1100;
    if (us > 1900) us = 1900;
    uint32_t duty = (us * 8191) / 20000;
    ledc_set_duty(LEDC_HIGH_SPEED_MODE, ch, duty);
    ledc_update_duty(LEDC_HIGH_SPEED_MODE, ch);
}

// ==========================================================
// 5. I2C UTILITY
// ==========================================================
void i2c_read_bytes(uint8_t addr, uint8_t reg, uint8_t *data, size_t len)
{
    i2c_cmd_handle_t link = i2c_cmd_link_create();
    i2c_master_start(link);
    i2c_master_write_byte(link, (addr << 1) | I2C_MASTER_WRITE, true);
    i2c_master_write_byte(link, reg, true);
    i2c_master_start(link);
    i2c_master_write_byte(link, (addr << 1) | I2C_MASTER_READ, true);
    i2c_master_read(link, data, len, I2C_MASTER_LAST_NACK);
    i2c_master_stop(link);
    i2c_master_cmd_begin(I2C_PORT, link, 100 / portTICK_PERIOD_MS);
    i2c_cmd_link_delete(link);
}

void i2c_write_cmd(uint8_t addr, uint8_t cmd_byte)
{
    i2c_cmd_handle_t link = i2c_cmd_link_create();
    i2c_master_start(link);
    i2c_master_write_byte(link, (addr << 1) | I2C_MASTER_WRITE, true);
    i2c_master_write_byte(link, cmd_byte, true);
    i2c_master_stop(link);
    i2c_master_cmd_begin(I2C_PORT, link, 100 / portTICK_PERIOD_MS);
    i2c_cmd_link_delete(link);
}

void i2c_write_byte(uint8_t addr, uint8_t reg, uint8_t data)
{
    i2c_cmd_handle_t link = i2c_cmd_link_create();
    i2c_master_start(link);
    i2c_master_write_byte(link, (addr << 1) | I2C_MASTER_WRITE, true);
    i2c_master_write_byte(link, reg, true);
    i2c_master_write_byte(link, data, true);
    i2c_master_stop(link);
    i2c_master_cmd_begin(I2C_PORT, link, 100 / portTICK_PERIOD_MS);
    i2c_cmd_link_delete(link);
}

// ==========================================================
// 6. MS5837 PRESSURE SENSOR
// ==========================================================
void ms5837_init()
{
    i2c_write_cmd(MS5837_ADDR, 0x1E);
    vTaskDelay(20 / portTICK_PERIOD_MS);

    for (int i = 0; i < 7; i++) {
        uint8_t b[2];
        i2c_read_bytes(MS5837_ADDR, 0xA0 + (i * 2), b, 2);
        C[i] = (b[0] << 8) | b[1];
    }
}

void ms5837_read_filter()
{
    uint8_t b[3];
    uint32_t D1, D2;

    // Read D1 (Pressure) - OSR 4096
    i2c_write_cmd(MS5837_ADDR, 0x48);
    vTaskDelay(10 / portTICK_PERIOD_MS);
    i2c_read_bytes(MS5837_ADDR, 0x00, b, 3);
    D1 = (b[0] << 16) | (b[1] << 8) | b[2];

    // Read D2 (Temperature) - OSR 4096
    i2c_write_cmd(MS5837_ADDR, 0x58);
    vTaskDelay(10 / portTICK_PERIOD_MS);
    i2c_read_bytes(MS5837_ADDR, 0x00, b, 3);
    D2 = (b[0] << 16) | (b[1] << 8) | b[2];

    // Calculate temperature and pressure
    int64_t dT = D2 - ((int64_t)C[5] * 256);
    int64_t TEMP = 2000 + (dT * (int64_t)C[6]) / 8388608;
    int64_t OFF = ((int64_t)C[2] * 131072) + (((int64_t)C[4] * dT) / 64);
    int64_t SENS = ((int64_t)C[1] * 65536) + (((int64_t)C[3] * dT) / 128);

    // Second order temperature compensation
    if (TEMP < 2000) {
        int64_t T2 = (3 * (dT * dT)) / 8589934592;
        int64_t OFF2 = (3 * ((TEMP - 2000) * (TEMP - 2000))) / 2;
        int64_t SENS2 = (5 * ((TEMP - 2000) * (TEMP - 2000))) / 8;
        if (TEMP < -1500) {
            OFF2 += 7 * ((TEMP + 1500) * (TEMP + 1500));
            SENS2 += 4 * ((TEMP + 1500) * (TEMP + 1500));
        }
        TEMP -= T2;
        OFF -= OFF2;
        SENS -= SENS2;
    }

    float P = (float)((D1 * SENS / 2097152 - OFF) / 32768) / 100.0f;

    if (pressure_baseline == 0)
        pressure_baseline = P;

    float raw_z = (P - pressure_baseline) * 100.0f / (997.0f * 9.80665f);
    smooth_z = (FILTER_ALPHA * raw_z) + ((1.0 - FILTER_ALPHA) * smooth_z);
}

// ==========================================================
// 7. MPU9250 IMU
// ==========================================================
void mpu9250_init()
{
    i2c_write_byte(MPU9250_ADDR, 0x6B, 0x00);
    vTaskDelay(10 / portTICK_PERIOD_MS);
}

void calibrate_gyro()
{
    float sum = 0;
    uint8_t r[14];

    for (int i = 0; i < 1000; i++) {
        i2c_read_bytes(MPU9250_ADDR, 0x3B, r, 14);
        int16_t gz = (r[12] << 8) | r[13];
        sum += gz;
        vTaskDelay(3 / portTICK_PERIOD_MS);
    }
    gyro_z_offset = sum / 1000.0f;
}

void read_gyro_and_integrate(float dt)
{
    uint8_t r[14];
    i2c_read_bytes(MPU9250_ADDR, 0x3B, r, 14);
    int16_t gz = (r[12] << 8) | r[13];

    gyro_z_dps = ((float)gz - gyro_z_offset) / 131.0f;

    if (fabs(gyro_z_dps) < GYRO_DEADBAND)
        gyro_z_dps = 0.0f;

    static float prev_gyro = 0.0f;
    gyro_z_dps = 0.8f * gyro_z_dps + 0.2f * prev_gyro;
    prev_gyro = gyro_z_dps;

    current_heading += gyro_z_dps * dt;

    while (current_heading > 180.0f) current_heading -= 360.0f;
    while (current_heading < -180.0f) current_heading += 360.0f;
}

// ==========================================================
// 8. COMMAND PARSER
// ==========================================================
void parse_cmd(char *s)
{
    if (strstr(s, "RESET")) {
        is_armed = true;
        target_depth = 0.0f;
        prev_target_depth = 0.0f;
        manual_yaw = 0.0f;
        manual_surge = 0.0f;

        current_heading = 0.0f;
        target_heading = 0.0f;
        heading_error_integral = 0.0f;
        prev_heading_error = 0.0f;

        depth_error_integral = 0.0f;

        pressure_baseline = 0;
        ms5837_read_filter();
        
        smooth_z = 0.0f;
        prev_z = 0.0f;
        
        printf(">>> SYSTEM ARMED & RESET ZERO\n");
        return;
    }

    if (strstr(s, "ARM")) {
        is_armed = true;
        printf(">>> SYSTEM ARMED\n");
        return;
    }

    if (strstr(s, "CALIB")) {
        calibrate_gyro();
        printf(">>> GYRO CALIBRATED\n");
        return;
    }

    // ✅ LỆNH RESET INTEGRAL TỪ PYTHON
    if (strstr(s, "RESET_INTEGRAL")) {
        depth_error_integral *= 0.3f;  // Giảm 70% thay vì reset hoàn toàn
        return;
    }

    if (strstr(s, "CMD:")) {
        float new_depth, new_yaw, new_surge;
        if (sscanf(s, "CMD:%f,%f,%f", &new_depth, &new_yaw, &new_surge) == 3) {
            target_depth = new_depth;
            manual_yaw = new_yaw;
            manual_surge = new_surge;
        }
    }
}

// ==========================================================
// 9. PWM OFFSET FUNCTION
// ==========================================================
float apply_offset(float pwm_val)
{
    if (pwm_val > 0.1f) return pwm_val + PWM_OFFSET;
    if (pwm_val < -0.1f) return pwm_val - PWM_OFFSET;
    return 0;
}

// ==========================================================
// 10. CONTROL LOOP - ✅ SMART INTEGRAL MANAGEMENT
// ==========================================================
void control_loop(float dt)
{
    if (!is_armed) {
        for (int i = 0; i < 6; i++)
            set_pwm(i, PWM_CENTER);
        
        depth_error_integral = 0.0f;
        return;
    }

    // ✅ PHÁT HIỆN TARGET THAY ĐỔI (AI tracking)
    float target_change = fabs(target_depth - prev_target_depth);
    
    if (target_change > TARGET_CHANGE_THRESHOLD) {
        // Target đổi > 3cm → giảm integral 50%
        depth_error_integral *= 0.5f;
    }
    
    prev_target_depth = target_depth;

    // ✅ DEPTH PID CONTROL
    float ez = smooth_z - target_depth;
    float dz = (smooth_z - prev_z) / dt;
    prev_z = smooth_z;

    // ✅ INTEGRAL với SMART ACCUMULATION
    if (fabs(ez) < 0.08f) {
        // Lỗi nhỏ < 8cm: tích lũy bình thường
        depth_error_integral += ez * dt;
    } else if (fabs(ez) < 0.15f) {
        // Lỗi vừa 8-15cm: tích lũy chậm hơn
        depth_error_integral += ez * dt * 0.5f;
    } else {
        // Lỗi lớn > 15cm: giảm dần integral
        depth_error_integral *= 0.90f;
    }

    // Anti-windup: giới hạn tích phân
    if (depth_error_integral > DEPTH_INTEGRAL_MAX) 
        depth_error_integral = DEPTH_INTEGRAL_MAX;
    if (depth_error_integral < -DEPTH_INTEGRAL_MAX) 
        depth_error_integral = -DEPTH_INTEGRAL_MAX;

    // ✅ PID OUTPUT
    float Tz = (Z_KP * ez + 
                Z_KI * depth_error_integral + 
                Z_KD * dz) * Z_SCALE;

    // HEADING HOLD PID
    float Ty = 0.0f;

    if (heading_hold_enabled && fabs(manual_yaw) < 5.0f) {
        float heading_error = current_heading - target_heading;

        while (heading_error > 180.0f) heading_error -= 360.0f;
        while (heading_error < -180.0f) heading_error += 360.0f;

        if (fabs(heading_error) > HEADING_DEADBAND) {
            if (fabs(heading_error) < 20.0f) {
                heading_error_integral += heading_error * dt;
                
                if (heading_error_integral > 30.0f) heading_error_integral = 30.0f;
                if (heading_error_integral < -30.0f) heading_error_integral = -30.0f;
            } else {
                heading_error_integral *= 0.9f;
            }

            float heading_derivative = (heading_error - prev_heading_error) / dt;
            prev_heading_error = heading_error;

            static float prev_derivative = 0.0f;
            heading_derivative = 0.7f * heading_derivative + 0.3f * prev_derivative;
            prev_derivative = heading_derivative;

            Ty = HEADING_KP * heading_error +
                 HEADING_KI * heading_error_integral +
                 HEADING_KD * heading_derivative;
        } else {
            heading_error_integral = 0.0f;
            prev_heading_error = 0.0f;
        }
    } else {
        Ty = manual_yaw;

        if (fabs(manual_yaw) >= 5.0f) {
            target_heading = current_heading;
            heading_error_integral = 0.0f;
        }
    }

    if (Ty > 250) Ty = 250;
    if (Ty < -250) Ty = -250;

    // MOTOR MIXING
    float m[6];

    m[0] = Tz;
    m[1] = -Tz;
    m[2] = -Tz;
    m[3] = Tz;

    m[4] = Ty - manual_surge;
    m[5] = Ty + manual_surge;

    for (int i = 0; i < 6; i++) {
        float val = apply_offset(m[i]);
        int pwm = PWM_CENTER + (int)val;
        
        if (pwm > PWM_CENTER + PWM_LIMIT) pwm = PWM_CENTER + PWM_LIMIT;
        if (pwm < PWM_CENTER - PWM_LIMIT) pwm = PWM_CENTER - PWM_LIMIT;
        
        set_pwm(i, pwm);
    }
}

// ==========================================================
// 11. TELEMETRY
// ==========================================================
void send_telemetry()
{
    char msg[80];
    snprintf(msg, sizeof(msg), "TELE:%.3f,%.1f,%.1f\n",
             smooth_z, 0.0f, current_heading);
    uart_write_bytes(UART_PORT, msg, strlen(msg));
}

// ==========================================================
// 12. MAIN LOOP
// ==========================================================
void app_main()
{
    printf("\n========================================\n");
    printf("   ROV CONTROL - SMART INTEGRAL PID\n");
    printf("   ✅ Z_KP: 15.5\n");
    printf("   ✅ Z_KI: 1.2 (Optimized)\n");
    printf("   ✅ Z_KD: 12.0 (Anti-oscillation)\n");
    printf("   ✅ Z_SCALE: 150\n");
    printf("   ✅ FILTER_ALPHA: 0.18\n");
    printf("   ✅ INTEGRAL_MAX: 12.0\n");
    printf("   ✅ SMART TARGET TRACKING\n");
    printf("========================================\n\n");
    
    i2c_init();
    pwm_init();
    uart_init();
    vTaskDelay(100 / portTICK_PERIOD_MS);

    mpu9250_init();
    ms5837_init();
    vTaskDelay(100 / portTICK_PERIOD_MS);

    printf(">>> Calibrating Gyro...\n");
    calibrate_gyro();
    printf(">>> Gyro offset: %.2f\n", gyro_z_offset);

    for (int i = 0; i < 6; i++)
        set_pwm(i, PWM_CENTER);
    vTaskDelay(3000 / portTICK_PERIOD_MS);

    last_time_us = esp_timer_get_time();

    uint8_t rx[BUF_SIZE];
    char line[128];
    int pos = 0;
    int telemetry_counter = 0;

    printf(">>> System Ready. Waiting for ARM command...\n\n");

    while (1) {
        int len = uart_read_bytes(UART_PORT, rx, BUF_SIZE, 5 / portTICK_PERIOD_MS);
        for (int i = 0; i < len; i++) {
            if (rx[i] == '\n') {
                line[pos] = 0;
                parse_cmd(line);
                pos = 0;
            } else if (pos < sizeof(line) - 1) {
                line[pos++] = rx[i];
            }
        }

        int64_t now = esp_timer_get_time();

        ms5837_read_filter();

        float dt = (now - last_time_us) / 1e6f;
        last_time_us = now;

        if (dt > 0.001f && dt < 0.1f) {
            read_gyro_and_integrate(dt);
            control_loop(dt);
        }

        if (++telemetry_counter >= 20) {
            send_telemetry();
            telemetry_counter = 0;
        }

        vTaskDelay(20 / portTICK_PERIOD_MS);
    }
}
