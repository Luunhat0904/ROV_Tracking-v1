import tkinter as tk
from tkinter import messagebox
import cv2
from PIL import Image, ImageTk
import serial
import time
import threading
import socket
import struct
import math

# ================= CONFIGURATION =================
# Cấu hình kết nối Camera & ROV
SERVER_IP = "127.0.0.1"
SERVER_PORT = 5001
SEND_W, SEND_H = 416, 416

SERIAL_PORT = '/dev/ttyTHS1'
BAUD_RATE = 57600

CAMERA_ID = 0
CAM_WIDTH = 640
CAM_HEIGHT = 480

# Cấu hình Logger Server (Thêm mới)
LOG_SERVER_IP = "127.0.0.1"
LOG_SERVER_PORT = 5002

# MANUAL CONTROL
MANUAL_SURGE_POWER = 60.0
MANUAL_YAW_POWER = 40.0

# AI TRACKING PARAMETERS
TARGET_AREA = 11000      
KP_YAW = 0.15           
KP_SURGE = 0.008        
KP_Z = 0.0008           

# CLASS DEFINITIONS
CLASS_COLORS = {
    0: (0, 255, 0),      # Green
    1: (0, 165, 255)     # Orange
}
CLASS_NAMES = {
    0: "CHAI_XANH",
    1: "CHAI_CAM"
}

# UI OVERLAY
Z_DEADBAND_PIXEL = 50
CENTER_OFFSET_Y = 40


class ROVHeadingHoldController:
    def __init__(self, root):
        self.root = root
        self.root.title("ROV HEADING HOLD + AI TRACKING (Logged)")
        self.root.geometry("1280x800")
        self.root.configure(bg="#0a0a0a")

        # ================= STATE =================
        self.current_mode = "MANUAL"
        self.is_running = True
        self.is_armed = False

        self.target_depth = 0.0
        self.cmd_surge = 0.0
        self.cmd_yaw = 0.0

        self.esp_depth = 0.0
        self.esp_pitch = 0.0
        self.esp_yaw = 0.0

        # AI Detection
        self.all_detections = []
        self.selected_target = None
        self.last_seen_time = 0
        self.ai_base_depth = 0.0

        self.latest_frame = None
        self.frame_for_ai = None
        self.lock = threading.Lock()
        self.serial_lock = threading.Lock()

        # ================= SOCKET LOGGING =================
        try:
            self.log_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        except Exception as e:
            print(f"Log Socket Error: {e}")
            self.log_sock = None

        # ================= HARDWARE =================
        try:
            self.ser = serial.Serial(SERIAL_PORT, BAUD_RATE, timeout=0.1)
            print(f"Serial: {SERIAL_PORT}")
        except Exception as e:
            self.ser = None
            print(f"SERIAL ERROR: {e}")

        self.cap = cv2.VideoCapture(CAMERA_ID, cv2.CAP_V4L2)
        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, CAM_WIDTH)
        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, CAM_HEIGHT)
        self.cap.set(cv2.CAP_PROP_BUFFERSIZE, 1)
        print(f"Camera {CAMERA_ID} opened")

        # ================= UI =================
        self.setup_ui()
        self.bind_keys()

        # ================= THREADS =================
        threading.Thread(target=self.thread_camera_read, daemon=True).start()
        threading.Thread(target=self.thread_ai_network, daemon=True).start()
        threading.Thread(target=self.thread_read_serial, daemon=True).start()
        threading.Thread(target=self.thread_send_serial, daemon=True).start()
        
        # Thêm thread gửi log
        threading.Thread(target=self.thread_logging, daemon=True).start()

        self.update_gui()

    # ================= UI SETUP =================
    def setup_ui(self):
        main = tk.Frame(self.root, bg="#0f0f0f")
        main.pack(fill=tk.BOTH, expand=True)

        # LEFT: Camera
        cam_container = tk.Frame(main, bg="black", highlightthickness=3, 
                                 highlightbackground="#00ff00")
        cam_container.pack(side=tk.LEFT, padx=10, pady=10, fill=tk.BOTH, expand=True)

        self.cam_lbl = tk.Label(cam_container, bg="black", 
                                text="INITIALIZING CAMERA...", 
                                fg="white", font=("Helvetica", 12))
        self.cam_lbl.pack(fill=tk.BOTH, expand=True)
        
        self.cam_lbl.bind("<Button-1>", self.on_click_select)
        self.cam_lbl.bind("<Button-3>", self.on_right_click_cancel)

        # RIGHT: Control Panel
        panel = tk.Frame(main, bg="#1a1a1a", width=400)
        panel.pack(side=tk.RIGHT, fill=tk.Y, padx=10, pady=10)

        # === 1. ARM BUTTON ===
        self.btn_arm = tk.Button(
            panel, text="ARM & RESET ZERO", 
            command=self.arm_system,
            bg="#cc0000", fg="white", 
            font=("Helvetica", 14, "bold"), height=2
        )
        self.btn_arm.pack(fill=tk.X, padx=12, pady=10)

        # === 2. MODE CONTROL ===
        mode_frame = tk.LabelFrame(
            panel, text=" OPERATION MODE ", 
            bg="#1a1a1a", fg="#ffcc00", 
            font=("Helvetica", 10, "bold"), bd=2
        )
        mode_frame.pack(fill=tk.X, padx=12, pady=8)

        btn_row = tk.Frame(mode_frame, bg="#1a1a1a")
        btn_row.pack(pady=8)

        self.btn_manual = tk.Button(
            btn_row, text="MANUAL", 
            command=self.set_manual,
            bg="#0066cc", fg="white", 
            font=("Helvetica", 10, "bold"), width=13
        )
        self.btn_manual.pack(side=tk.LEFT, padx=4)

        self.btn_ai = tk.Button(
            btn_row, text="AI TRACK", 
            command=self.toggle_ai,
            bg="#555", fg="white", 
            font=("Helvetica", 10, "bold"), width=13
        )
        self.btn_ai.pack(side=tk.LEFT, padx=4)

        self.lbl_mode = tk.Label(
            mode_frame, text="MANUAL + HEADING HOLD", 
            bg="#1a1a1a", fg="#00ff00", 
            font=("Helvetica", 12, "bold")
        )
        self.lbl_mode.pack(pady=6)

        # === 3. DETECTION STATUS ===
        detect_frame = tk.LabelFrame(
            panel, text=" AI DETECTION ", 
            bg="#1a1a1a", fg="#00ccff", 
            font=("Helvetica", 10, "bold"), bd=2
        )
        detect_frame.pack(fill=tk.X, padx=12, pady=8)

        self.lbl_detections = tk.Label(
            detect_frame, text="Green: 0 | Orange: 0", 
            bg="#1a1a1a", fg="white", 
            font=("Courier", 11)
        )
        self.lbl_detections.pack(pady=4)

        self.lbl_target = tk.Label(
            detect_frame, 
            text="NO TARGET SELECTED\n(Click object to track)", 
            bg="#1a1a1a", fg="yellow", 
            font=("Courier", 10, "bold"), 
            justify=tk.CENTER
        )
        self.lbl_target.pack(pady=6)

        # === 4. TELEMETRY ===
        tele_frame = tk.LabelFrame(
            panel, text=" TELEMETRY ", 
            bg="#1a1a1a", fg="#00ccff", 
            font=("Helvetica", 10, "bold"), bd=2
        )
        tele_frame.pack(fill=tk.X, padx=12, pady=8)

        self.lbl_depth = tk.Label(
            tele_frame, text="DEPTH: 0.000 m", 
            bg="#1a1a1a", fg="white", 
            font=("Courier", 20, "bold")
        )
        self.lbl_depth.pack(pady=4)

        self.lbl_heading = tk.Label(
            tele_frame, text="HEADING: 0.0 deg | Target: 0.0 deg", 
            bg="#1a1a1a", fg="#00ff00", 
            font=("Courier", 11, "bold")
        )
        self.lbl_heading.pack(pady=4)

        self.lbl_pitch = tk.Label(
            tele_frame, text="Pitch: 0.0 deg", 
            bg="#1a1a1a", fg="#aaa", 
            font=("Helvetica", 10)
        )
        self.lbl_pitch.pack(pady=2)

        # === 5. DEPTH CONTROL ===
        depth_frame = tk.LabelFrame(
            panel, text=" DEPTH CONTROL (m) ", 
            bg="#1a1a1a", fg="white", 
            font=("Helvetica", 10, "bold"), bd=2
        )
        depth_frame.pack(fill=tk.X, padx=12, pady=8)

        self.lbl_target_depth = tk.Label(
            depth_frame, text="TARGET: 0.00 m", 
            bg="#1a1a1a", fg="#00ff00", 
            font=("Courier", 16, "bold")
        )
        self.lbl_target_depth.pack(pady=6)

        depth_input = tk.Frame(depth_frame, bg="#1a1a1a")
        depth_input.pack(pady=6)

        self.ent_depth = tk.Entry(
            depth_input, width=8, 
            font=("Helvetica", 13), justify='center'
        )
        self.ent_depth.insert(0, "0.0")
        self.ent_depth.pack(side=tk.LEFT, padx=4)
        self.ent_depth.bind("<Return>", self.set_depth)

        tk.Button(
            depth_input, text="SET", command=self.set_depth,
            bg="#00aa00", fg="white", 
            font=("Helvetica", 10, "bold"), width=7
        ).pack(side=tk.LEFT, padx=3)

        tk.Button(
            depth_input, text="RESET", command=self.reset_depth,
            bg="#0066cc", fg="white", 
            font=("Helvetica", 10), width=7
        ).pack(side=tk.LEFT, padx=3)

        # === 6. INFO ===
        info_text = (
            "CONTROLS:\n"
            "- Heading Hold: Auto keep 0 deg\n"
            "- W/S: Forward/Back\n"
            "- A/D: Rotate Left/Right\n"
            "- Left Click: Select target\n"
            "- Right Click: Cancel tracking\n"
            "- LOGGING ACTIVE (Port 5002)"
        )
        
        info_lbl = tk.Label(
            panel, text=info_text, 
            bg="#1a1a1a", fg="#888", 
            font=("Helvetica", 8), justify=tk.LEFT
        )
        info_lbl.pack(side=tk.BOTTOM, pady=12, padx=10)

    # ================= CONTROL FUNCTIONS =================
    def arm_system(self):
        if self.ser:
            with self.serial_lock:
                for _ in range(3):
                    self.ser.write(b"RESET\n")
                    time.sleep(0.05)
        
        self.is_armed = True
        self.btn_arm.config(text="SYSTEM ARMED", bg="#00aa00")
        print(">>> ARMED & RESET ZERO")

    def set_manual(self):
        self.current_mode = "MANUAL"
        self.cmd_surge = 0
        self.cmd_yaw = 0
        self.lbl_mode.config(text="MANUAL + HEADING HOLD", fg="#00ff00")
        self.btn_ai.config(bg="#555")

    def toggle_ai(self):
        if not self.is_armed:
            messagebox.showwarning("Warning", "Please ARM system first!")
            return
        
        if not self.selected_target:
            messagebox.showwarning("Warning", 
                "No target selected!\nClick on object to track.")
            return

        if self.current_mode == "AI_TRACKING":
            self.set_manual()
        else:
            self.current_mode = "AI_TRACKING"
            self.ai_base_depth = self.esp_depth
            
            class_name = CLASS_NAMES.get(self.selected_target[0], "UNKNOWN")
            self.lbl_mode.config(text=f"TRACKING: {class_name}", fg="orange")
            self.btn_ai.config(bg="#d9534f")
            print(f">>> AI TRACKING: {class_name} | Base Depth: {self.ai_base_depth:.3f}m")

    def set_depth(self, event=None):
        if self.current_mode == "AI_TRACKING":
            messagebox.showwarning("Warning", 
                "Cannot set depth in AI mode!\nSwitch to MANUAL first.")
            return
            
        try:
            val = float(self.ent_depth.get())
            self.target_depth = max(0, min(3.0, val))
            self.lbl_target_depth.config(text=f"TARGET: {self.target_depth:.2f} m")
        except:
            self.lbl_target_depth.config(text="INVALID INPUT")
        self.root.focus_set()

    def reset_depth(self):
        if self.current_mode == "AI_TRACKING":
            messagebox.showwarning("Warning", 
                "Cannot reset depth in AI mode!\nSwitch to MANUAL first.")
            return
            
        self.target_depth = 0.0
        self.ent_depth.delete(0, tk.END)
        self.ent_depth.insert(0, "0.0")
        self.lbl_target_depth.config(text="TARGET: 0.00 m")
        self.root.focus_set()

    # ================= MOUSE INTERACTION =================
    def on_click_select(self, event):
        if not self.all_detections:
            return

        lbl_w = self.cam_lbl.winfo_width()
        lbl_h = self.cam_lbl.winfo_height()
        scale_x = CAM_WIDTH / lbl_w
        scale_y = CAM_HEIGHT / lbl_h
        
        click_x = event.x * scale_x
        click_y = event.y * scale_y

        min_dist = 999999
        best_obj = None

        for obj in self.all_detections:
            cls_id, conf, cx, cy, w, h = obj
            dist = math.sqrt((cx - click_x)**2 + (cy - click_y)**2)
            
            if dist < min(w, h) and dist < min_dist:
                min_dist = dist
                best_obj = obj

        if best_obj:
            self.selected_target = best_obj
            self.last_seen_time = time.time()
            class_name = CLASS_NAMES.get(best_obj[0], "UNKNOWN")
            self.lbl_target.config(
                text=f"LOCKED: {class_name}\nConf: {best_obj[1]:.2f}", 
                fg="#00ff00"
            )
            print(f">>> TARGET LOCKED: {class_name}")
        else:
            self.lbl_target.config(
                text="MISSED!\nClick closer to object", 
                fg="red"
            )

    def on_right_click_cancel(self, event=None):
        self.selected_target = None
        self.lbl_target.config(
            text="TARGET CLEARED\n(Click to select again)", 
            fg="yellow"
        )
        self.set_manual()
        print(">>> TARGET UNLOCKED")

    # ================= AI TRACKING =================
    def calc_ai_tracking(self):
        if not self.selected_target or not self.all_detections:
            self.cmd_surge = 0
            self.cmd_yaw = 0
            return

        target_class = self.selected_target[0]
        best_match = None
        min_dist = 999999

        for obj in self.all_detections:
            if obj[0] == target_class:
                dist = math.sqrt(
                    (obj[2] - self.selected_target[2])**2 + 
                    (obj[3] - self.selected_target[3])**2
                )
                if dist < min_dist:
                    min_dist = dist
                    best_match = obj

        if best_match:
            self.selected_target = best_match
            self.last_seen_time = time.time()
            cls_id, conf, cx, cy, w, h = best_match

            if cy < (CAM_HEIGHT * 0.3):
                self.cmd_surge = 0
                self.cmd_yaw = 0
                return

            error_x = cx - (CAM_WIDTH / 2)
            self.cmd_yaw = max(-60, min(60, -error_x * KP_YAW))

            current_area = w * h
            error_area = TARGET_AREA - current_area
            self.cmd_surge = max(-60, min(60, -error_area * KP_SURGE))

            target_y = (CAM_HEIGHT / 2) + CENTER_OFFSET_Y
            error_y = cy - target_y

            if abs(error_y) > Z_DEADBAND_PIXEL:
                depth_adjustment = error_y * KP_Z
                self.target_depth = self.ai_base_depth + depth_adjustment
                self.target_depth = max(0.0, min(3.0, self.target_depth))

        else:
            if time.time() - self.last_seen_time > 2.0:
                self.cmd_surge = 0
                self.cmd_yaw = 0
                self.lbl_target.config(
                    text="TARGET LOST\n(Searching...)", 
                    fg="orange"
                )

    # ================= LOGGING THREAD (NEW) =================
    def thread_logging(self):
        """Thread gửi dữ liệu đến Logger Server qua UDP"""
        print(f"Log Thread Started -> {LOG_SERVER_IP}:{LOG_SERVER_PORT}")
        
        while self.is_running:
            if not self.log_sock:
                time.sleep(1)
                continue

            # 1. Prepare Data
            ts = time.time()
            
            # Format Mode (20 bytes)
            mode_bytes = self.current_mode.encode('utf-8')[:20]
            mode_bytes = mode_bytes.ljust(20, b'\x00')
            
            # AI Data
            ai_cls_name = b""
            ai_conf = 0.0
            ai_cx = 0.0
            ai_cy = 0.0
            ai_area = 0.0

            if self.selected_target:
                cls_id, conf, cx, cy, w, h = self.selected_target
                name_str = CLASS_NAMES.get(cls_id, "UNK")
                ai_cls_name = name_str.encode('utf-8')[:10]
                ai_conf = float(conf)
                ai_cx = float(cx)
                ai_cy = float(cy)
                ai_area = float(w * h)
            
            ai_cls_name = ai_cls_name.ljust(10, b'\x00')

            # 2. Pack Binary Data (Cấu trúc 82 bytes)
            # 'd' = timestamp (8)
            # '20s' = mode (20)
            # 7 'f's = telemetry (28)
            # '10s' = ai_class (10)
            # 4 'f's = ai_data (16)
            try:
                packet = struct.pack(
                    'd20sfffffff10sffff',
                    ts,                     # timestamp
                    mode_bytes,             # mode
                    self.esp_depth,         # depth_current
                    self.target_depth,      # depth_target
                    self.esp_yaw,           # yaw_current
                    0.0,                    # yaw_target (giả sử 0)
                    self.esp_pitch,         # pitch
                    self.cmd_surge,         # cmd_surge
                    self.cmd_yaw,           # cmd_yaw
                    ai_cls_name,            # ai_target_class
                    ai_conf,                # ai_confidence
                    ai_cx,                  # ai_cx
                    ai_cy,                  # ai_cy
                    ai_area                 # ai_area
                )
                
                self.log_sock.sendto(packet, (LOG_SERVER_IP, LOG_SERVER_PORT))
            
            except Exception as e:
                print(f"LOG ERROR: {e}")

            time.sleep(0.1) # Gửi log ở tần số 10Hz

    # ================= KEYBOARD =================
    def bind_keys(self):
        self.root.bind('<KeyPress-w>', lambda e: self.manual_key("FWD", True))
        self.root.bind('<KeyRelease-w>', lambda e: self.manual_key("FWD", False))
        self.root.bind('<KeyPress-s>', lambda e: self.manual_key("BWD", True))
        self.root.bind('<KeyRelease-s>', lambda e: self.manual_key("BWD", False))
        self.root.bind('<KeyPress-a>', lambda e: self.manual_key("LEFT", True))
        self.root.bind('<KeyRelease-a>', lambda e: self.manual_key("LEFT", False))
        self.root.bind('<KeyPress-d>', lambda e: self.manual_key("RIGHT", True))
        self.root.bind('<KeyRelease-d>', lambda e: self.manual_key("RIGHT", False))

    def manual_key(self, action, pressed):
        if self.root.focus_get() == self.ent_depth:
            return
        if not self.is_armed or self.current_mode != "MANUAL":
            return

        if not pressed:
            if action in ["FWD", "BWD"]:
                self.cmd_surge = 0
            if action in ["LEFT", "RIGHT"]:
                self.cmd_yaw = 0
        else:
            if action == "FWD":
                self.cmd_surge = -MANUAL_SURGE_POWER
            elif action == "BWD":
                self.cmd_surge = MANUAL_SURGE_POWER
            elif action == "LEFT":
                self.cmd_yaw = MANUAL_YAW_POWER
            elif action == "RIGHT":
                self.cmd_yaw = -MANUAL_YAW_POWER

    # ================= THREADS =================
    def thread_send_serial(self):
        while self.is_running:
            if self.current_mode == "AI_TRACKING":
                self.calc_ai_tracking()

            if self.ser and self.is_armed:
                cmd = f"CMD:{self.target_depth:.3f},{self.cmd_yaw:.1f},{self.cmd_surge:.1f}\n"
                try:
                    with self.serial_lock:
                        self.ser.write(cmd.encode())
                except:
                    pass
            
            time.sleep(0.1)

    def thread_read_serial(self):
        while self.is_running:
            if self.ser and self.ser.in_waiting:
                try:
                    line = self.ser.readline().decode('utf-8', errors='ignore').strip()
                    if "TELE:" in line:
                        parts = line.replace("TELE:", "").split(",")
                        if len(parts) >= 3:
                            self.esp_depth = float(parts[0])
                            self.esp_pitch = float(parts[1])
                            self.esp_yaw = float(parts[2])
                except:
                    pass
            time.sleep(0.01)

    def thread_camera_read(self):
        while self.is_running:
            ret, frame = self.cap.read()
            if ret:
                with self.lock:
                    self.latest_frame = frame
                    if self.frame_for_ai is None:
                        self.frame_for_ai = frame.copy()
            time.sleep(0.03)

    def thread_ai_network(self):
        def connect():
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(3.0)
                sock.connect((SERVER_IP, SERVER_PORT))
                print(f"AI Server: {SERVER_IP}:{SERVER_PORT}")
                return sock
            except:
                return None

        sock = connect()

        while self.is_running:
            img = None
            with self.lock:
                if self.frame_for_ai is not None:
                    img = self.frame_for_ai
                    self.frame_for_ai = None

            if img is None:
                time.sleep(0.01)
                continue

            if not sock:
                sock = connect()
                time.sleep(1)
                continue

            try:
                img_r = cv2.resize(img, (SEND_W, SEND_H))
                _, jpg = cv2.imencode(".jpg", img_r, [cv2.IMWRITE_JPEG_QUALITY, 60])
                data = jpg.tobytes()
                sock.sendall(struct.pack("I", len(data)) + data)

                response = sock.recv(49)
                if len(response) == 49:
                    detections = []

                    for i in range(2):
                        offset = 1 + i * 24
                        cls_id, conf, cx, cy, w, h = struct.unpack("I5f", response[offset:offset+24])
                        
                        if conf > 0:
                            sx = CAM_WIDTH / SEND_W
                            sy = CAM_HEIGHT / SEND_H
                            detections.append((
                                cls_id, conf, 
                                cx * sx, cy * sy, 
                                w * sx, h * sy
                            ))

                    self.all_detections = detections

            except:
                sock = None
                self.all_detections = []
                time.sleep(0.5)

    # ================= GUI UPDATE =================
    def update_gui(self):
        # Telemetry
        self.lbl_depth.config(text=f"DEPTH: {self.esp_depth:.3f} m")
        self.lbl_heading.config(text=f"HEADING: {self.esp_yaw:.1f} deg | Target: 0.0 deg")
        self.lbl_pitch.config(text=f"Pitch: {self.esp_pitch:.1f} deg")

        self.lbl_target_depth.config(text=f"TARGET: {self.target_depth:.2f} m")

        # Detection count
        green_cnt = sum(1 for o in self.all_detections if o[0] == 0)
        orange_cnt = sum(1 for o in self.all_detections if o[0] == 1)
        self.lbl_detections.config(text=f"Green: {green_cnt} | Orange: {orange_cnt}")

        # Draw frame
        frame = None
        with self.lock:
            if self.latest_frame is not None:
                frame = self.latest_frame.copy()

        if frame is not None:
            for obj in self.all_detections:
                cls_id, conf, cx, cy, w, h = obj
                x1 = int(cx - w/2)
                y1 = int(cy - h/2)
                x2 = int(cx + w/2)
                y2 = int(cy + h/2)

                color = CLASS_COLORS.get(cls_id, (255, 255, 255))
                name = CLASS_NAMES.get(cls_id, "UNK")

                thickness = 2
                if self.selected_target and self.selected_target[0] == cls_id:
                    dist = math.sqrt(
                        (cx - self.selected_target[2])**2 + 
                        (cy - self.selected_target[3])**2
                    )
                    if dist < 80:
                        thickness = 4
                        cv2.circle(frame, (int(cx), int(cy)), 10, (0, 0, 255), -1)
                        cv2.putText(frame, "LOCKED", (x1, y1-30), 
                                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)

                cv2.rectangle(frame, (x1, y1), (x2, y2), color, thickness)
                cv2.putText(frame, f"{name} {conf:.2f}", (x1, y1-8), 
                            cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 2)

            cv2.line(frame, (CAM_WIDTH//2, 0), (CAM_WIDTH//2, CAM_HEIGHT), (0, 255, 0), 1)
            target_y = CAM_HEIGHT//2 + CENTER_OFFSET_Y
            cv2.line(frame, (0, target_y - Z_DEADBAND_PIXEL), 
                     (CAM_WIDTH, target_y - Z_DEADBAND_PIXEL), (0, 255, 255), 1)
            cv2.line(frame, (0, target_y + Z_DEADBAND_PIXEL), 
                     (CAM_WIDTH, target_y + Z_DEADBAND_PIXEL), (0, 255, 255), 1)
            cv2.line(frame, (0, target_y), (CAM_WIDTH, target_y), (0, 255, 0), 1)

            img_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            img_pil = Image.fromarray(img_rgb)
            img_tk = ImageTk.PhotoImage(img_pil)
            self.cam_lbl.imgtk = img_tk
            self.cam_lbl.configure(image=img_tk)

        self.root.after(30, self.update_gui)

    # ================= CLEANUP =================
    def close(self):
        self.is_running = False
        if self.cap:
            self.cap.release()
        if self.ser:
            self.ser.close()
        self.root.destroy()
        print(">>> SHUTDOWN")


if __name__ == "__main__":
    root = tk.Tk()
    app = ROVHeadingHoldController(root)
    root.protocol("WM_DELETE_WINDOW", app.close)
    root.mainloop()
